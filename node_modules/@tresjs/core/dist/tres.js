/**
 * name: @tresjs/core
 * version: v3.7.0
 * (c) 2024
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var je = Object.defineProperty;
var He = (e, r, t) => r in e ? je(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
var J = (e, r, t) => (He(e, typeof r != "symbol" ? r + "" : r, t), t);
import { ref as R, computed as P, watchEffect as O, onUnmounted as F, shallowRef as D, watch as me, reactive as ge, readonly as Re, provide as q, inject as $e, createRenderer as Ie, defineComponent as ne, useSlots as ze, getCurrentInstance as oe, onMounted as Ne, openBlock as Ve, createElementBlock as We, normalizeClass as Ue, unref as Fe, normalizeStyle as Ge, h as se, Fragment as Je } from "vue";
import * as ve from "three";
import { PerspectiveCamera as K, OrthographicCamera as Qe, Camera as Ye, Clock as qe, Vector3 as he, Color as V, MeshBasicMaterial as ye, DoubleSide as Ke, REVISION as Xe, SRGBColorSpace as Ze, ACESFilmicToneMapping as et, PCFSoftShadowMap as tt, WebGLRenderer as Q, LoadingManager as rt, TextureLoader as nt, Vector2 as ot, Raycaster as st, BufferAttribute as it, Scene as at, Line as lt, BufferGeometry as ie, Float32BufferAttribute as ae, LineBasicMaterial as ut, Mesh as ct, BackSide as dt, DirectionalLightHelper as ft, PointLightHelper as pt, SpotLightHelper as mt, HemisphereLightHelper as gt, ArrowHelper as vt } from "three";
import { createEventHook as H, useRafFn as we, toValue as M, unrefElement as ht, useDevicePixelRatio as yt, usePointer as wt, useElementBounding as bt, useWindowSize as _t, useElementSize as Et, refDebounced as Mt, useFps as Ct, useMemory as St } from "@vueuse/core";
const xt = "@tresjs/core", Pt = "module", kt = "3.7.0", At = "pnpm@8.10.2", Tt = "Declarative ThreeJS using Vue Components", Lt = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", Ot = "MIT", Dt = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
], Bt = !1, jt = {
  ".": {
    types: "./dist/index.d.ts",
    require: "./dist/tres.umd.cjs",
    import: "./dist/tres.js"
  },
  "./components": {
    types: "./dist/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/utils/index.d.ts"
  },
  "./*": "./*"
}, Ht = "./dist/tres.js", Rt = "./dist/tres.js", $t = "./dist/index.d.ts", It = [
  "dist",
  "*.d.ts"
], zt = {
  access: "public"
}, Nt = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint . --ext .js,.jsx,.ts,.tsx,.vue",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts"
}, Vt = {
  three: ">=0.133",
  vue: ">=3.3"
}, Wt = {
  "@alvarosabu/utils": "^3.1.1",
  "@vueuse/core": "^10.7.0"
}, Ut = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.6.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.159.0",
  "@typescript-eslint/eslint-plugin": "^6.14.0",
  "@typescript-eslint/parser": "^6.14.0",
  "@vitejs/plugin-vue": "^4.5.2",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.0.4",
  "@vue/test-utils": "^2.4.3",
  eslint: "^8.55.0",
  "eslint-plugin-vue": "^9.19.2",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  jsdom: "^23.0.1",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.0.1",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.159.0",
  unocss: "^0.58.0",
  unplugin: "^1.5.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.0.8",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.6.4",
  "vite-plugin-inspect": "^0.8.1",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.0.0-rc.31",
  vitest: "^1.0.4",
  vue: "^3.3.11",
  "vue-demi": "^0.14.6"
}, Ft = {
  name: xt,
  type: Pt,
  version: kt,
  packageManager: At,
  description: Tt,
  author: Lt,
  license: Ot,
  keywords: Dt,
  sideEffects: Bt,
  exports: jt,
  main: Ht,
  module: Rt,
  types: $t,
  files: It,
  publishConfig: zt,
  scripts: Nt,
  peerDependencies: Vt,
  dependencies: Wt,
  devDependencies: Ut
}, Gt = ({ sizes: e, scene: r }) => {
  const t = R([]), n = P(
    () => t.value[0]
  ), s = (i, l = !1) => {
    t.value.some(({ uuid: c }) => c === i.uuid) || (l ? o(i) : t.value.push(i));
  }, a = (i) => {
    t.value = t.value.filter(({ uuid: l }) => l !== i.uuid);
  }, o = (i) => {
    const l = i instanceof Ye ? i : t.value.find((p) => p.uuid === i);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: p }) => p !== l.uuid);
    t.value = [l, ...c];
  };
  return O(() => {
    e.aspectRatio.value && t.value.forEach((i) => {
      i instanceof K && (i.aspect = e.aspectRatio.value), (i instanceof K || i instanceof Qe) && i.updateProjectionMatrix();
    });
  }), r.userData.tres__registerCamera = s, r.userData.tres__deregisterCamera = a, F(() => {
    t.value = [];
  }), {
    camera: n,
    cameras: t,
    registerCamera: s,
    deregisterCamera: a,
    setCameraActive: o
  };
}, be = H(), _e = H(), ee = H(), j = new qe();
let W = 0, U = 0;
const { pause: Jt, resume: Qt, isActive: Yt } = we(
  () => {
    be.trigger({ delta: W, elapsed: U, clock: j }), _e.trigger({ delta: W, elapsed: U, clock: j }), ee.trigger({ delta: W, elapsed: U, clock: j });
  },
  { immediate: !1 }
);
ee.on(() => {
  W = j.getDelta(), U = j.getElapsedTime();
});
const te = () => ({
  onBeforeLoop: be.on,
  onLoop: _e.on,
  onAfterLoop: ee.on,
  pause: Jt,
  resume: Qt,
  isActive: Yt
}), Vr = !0, le = "[TresJS ▲ ■ ●] ";
function T() {
  function e(n, s) {
    console.error(`${le} ${n}`, s || "");
  }
  function r(n) {
    console.warn(`${le} ${n}`);
  }
  function t(n, s) {
  }
  return {
    logError: e,
    logWarning: r,
    logMessage: t
  };
}
function Wr(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof he ? [e.x, e.y, e.z] : e;
}
function qt(e) {
  return e instanceof V ? e : Array.isArray(e) ? new V(...e) : new V(e);
}
class Kt extends ve.Mesh {
  constructor(...t) {
    super(...t);
    J(this, "type", "HightlightMesh");
    J(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const n = (Date.now() - this.createTime) / 1e3, o = 1 + 0.07 * Math.sin(2.5 * n);
    this.scale.set(o, o, o);
  }
}
const Ee = (e, r) => {
  for (const t of Object.keys(r))
    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
  return Object.assign(e || {}, r), e;
}, Xt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Zt = /* @__PURE__ */ er(Xt);
function ue(e) {
  return e && e.nodeType === 1;
}
function I(e) {
  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
}
function er(e, r) {
  const t = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let s = 0; s < n.length; s++)
    t[n[s]] = !0;
  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
}
const tr = (e, r) => {
  const t = /* @__PURE__ */ new Set(), n = [];
  for (const s of e) {
    const a = r(s);
    t.has(a) || (t.add(a), n.push(s));
  }
  return n;
}, ce = (e, r) => {
  if (!r)
    return;
  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((n, s) => n && n[s], e);
}, rr = (e, r, t) => {
  const n = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  n && n.reduce((s, a, o) => (s[a] === void 0 && (s[a] = {}), o === n.length - 1 && (s[a] = t), s[a]), e);
};
function Me(e, r) {
  if (ue(e) && ue(r)) {
    const s = e.attributes, a = r.attributes;
    return s.length !== a.length ? !1 : Array.from(s).every(({ name: o, value: i }) => r.getAttribute(o) === i);
  }
  if (e === r)
    return !0;
  if (e === null || typeof e != "object" || r === null || typeof r != "object")
    return !1;
  const t = Object.keys(e), n = Object.keys(r);
  if (t.length !== n.length)
    return !1;
  for (const s of t)
    if (!n.includes(s) || !Me(e[s], r[s]))
      return !1;
  return !0;
}
function nr(e, r) {
  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (!Me(e[t], r[t]))
      return !1;
  return !0;
}
const or = Array.isArray;
function sr(e, r, t, n) {
  const s = (l) => {
    if (l.uuid === r)
      return l;
    for (const c of l.children) {
      const p = s(c);
      if (p)
        return p;
    }
  }, a = s(e);
  if (!a) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let o = a;
  for (let l = 0; l < t.length - 1; l++)
    if (o[t[l]] !== void 0)
      o = o[t[l]];
    else {
      console.warn(`Property path is not valid: ${t.join(".")}`);
      return;
    }
  const i = t[t.length - 1];
  o[i] !== void 0 ? o[i] = n : console.warn(`Property path is not valid: ${t.join(".")}`);
}
function ir(e) {
  const r = new ye({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: !0,
    opacity: 0.2,
    depthTest: !1,
    // So the highlight is always visible
    side: Ke
    // To e
  });
  return new Kt(e.geometry.clone(), r);
}
function Ce(e) {
  var t;
  let r = e.value;
  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new he(...r)), r;
}
const ar = Number.parseInt(Xe.replace("dev", "")), z = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: Ze,
    toneMapping: et,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: tt
    }
  }
};
function lr({
  scene: e,
  canvas: r,
  options: t,
  disableRender: n,
  contextParts: { sizes: s, camera: a }
}) {
  const o = P(() => ({
    alpha: M(t.alpha),
    depth: M(t.depth),
    canvas: ht(r),
    context: M(t.context),
    stencil: M(t.stencil),
    antialias: M(t.antialias) === void 0 ? !0 : M(t.antialias),
    precision: M(t.precision),
    powerPreference: M(t.powerPreference),
    premultipliedAlpha: M(t.premultipliedAlpha),
    preserveDrawingBuffer: M(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: M(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: M(t.failIfMajorPerformanceCaveat)
  })), i = D(new Q(o.value));
  me(o, () => {
    i.value.dispose(), i.value = new Q(o.value);
  }), O(() => {
    i.value.setSize(s.width.value, s.height.value);
  });
  const { pixelRatio: l } = yt();
  O(() => {
    i.value.setPixelRatio(l.value);
  });
  const { logError: c } = T(), d = (() => {
    const f = new Q(), h = {
      shadowMap: {
        enabled: f.shadowMap.enabled,
        type: f.shadowMap.type
      },
      toneMapping: f.toneMapping,
      toneMappingExposure: f.toneMappingExposure,
      outputColorSpace: f.outputColorSpace
    };
    return f.dispose(), h;
  })();
  O(() => {
    const f = M(t.preset);
    f && (f in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(i.value, z[f]));
    const h = (C, S) => {
      const b = M(C), x = () => {
        if (f)
          return ce(z[f], S);
      };
      if (b !== void 0)
        return b;
      const g = x();
      return g !== void 0 ? g : ce(d, S);
    }, _ = (C, S) => rr(i.value, S, h(C, S));
    _(t.shadows, "shadowMap.enabled"), _(t.toneMapping, "toneMapping"), _(t.shadowMapType, "shadowMap.type"), ar < 150 && _(!t.useLegacyLights, "physicallyCorrectLights"), _(t.outputColorSpace, "outputColorSpace"), _(t.toneMappingExposure, "toneMappingExposure");
    const w = h(t.clearColor, "clearColor");
    w && i.value.setClearColor(
      w ? qt(w) : new V(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: m, onLoop: y } = te();
  return y(() => {
    a.value && !M(n) && i.value.render(e, a.value);
  }), m(), F(() => {
    u(), i.value.dispose(), i.value.forceContextLoss();
  }), {
    renderer: i
  };
}
const de = (e) => typeof e == "function", ur = (e) => !!e && e.constructor === Array;
function cr(e) {
  const r = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
  }), r;
}
async function Ur(e, r, t, n, s) {
  const { logError: a } = T(), o = new e();
  s && s(o), t && t(o);
  const l = (Array.isArray(r) ? r : [r]).map(
    (c) => new Promise((p, d) => {
      o.load(
        c,
        (u) => {
          u.scene && Object.assign(u, cr(u.scene)), p(u);
        },
        n,
        (u) => d(a("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return ur(r) ? await Promise.all(l) : await l[0];
}
async function Fr(e) {
  const r = new rt(), t = new nt(r), n = (s) => new Promise((a, o) => {
    t.load(
      s,
      (i) => a(i),
      () => null,
      () => {
        o(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (or(e)) {
    const s = await Promise.all(e.map((a) => n(a)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: a,
      normalMap: o,
      roughnessMap: i,
      metalnessMap: l,
      aoMap: c,
      alphaMap: p,
      matcap: d
    } = e;
    return {
      map: s ? await n(s) : null,
      displacementMap: a ? await n(a) : null,
      normalMap: o ? await n(o) : null,
      roughnessMap: i ? await n(i) : null,
      metalnessMap: l ? await n(l) : null,
      aoMap: c ? await n(c) : null,
      alphaMap: p ? await n(p) : null,
      matcap: d ? await n(d) : null
    };
  }
}
const dr = (e, { renderer: r, camera: t, raycaster: n }) => {
  const s = P(() => r.value.domElement), { x: a, y: o } = wt({ target: s }), { width: i, height: l, top: c, left: p } = bt(s), d = ({ x: g, y: E }) => {
    if (s.value)
      return {
        x: (g - p.value) / i.value * 2 - 1,
        y: -((E - c.value) / l.value) * 2 + 1
      };
  }, u = ({ x: g, y: E }) => {
    if (t.value)
      return n.value.setFromCamera(new ot(g, E), t.value), n.value.intersectObjects(e.value, !1);
  }, m = (g) => {
    const E = d({
      x: (g == null ? void 0 : g.clientX) ?? a.value,
      y: (g == null ? void 0 : g.clientY) ?? o.value
    });
    return E ? u(E) || [] : [];
  }, y = P(() => m()), f = H(), h = H(), _ = (g, E) => {
    g.trigger({ event: E, intersects: m(E) });
  }, w = (g) => {
    _(h, g);
  };
  let C;
  const S = (g) => {
    var E;
    C = (E = m(g)[0]) == null ? void 0 : E.object;
  }, b = (g) => {
    var E;
    g instanceof PointerEvent && C === ((E = m(g)[0]) == null ? void 0 : E.object) && _(f, g);
  }, x = (g) => h.trigger({ event: g, intersects: [] });
  return s.value.addEventListener("pointerup", b), s.value.addEventListener("pointerdown", S), s.value.addEventListener("pointermove", w), s.value.addEventListener("pointerleave", x), F(() => {
    s != null && s.value && (s.value.removeEventListener("pointerup", b), s.value.removeEventListener("pointerdown", S), s.value.removeEventListener("pointermove", w), s.value.removeEventListener("pointerleave", x));
  }), {
    intersects: y,
    onClick: (g) => f.on(g).off,
    onPointerMove: (g) => h.on(g).off
  };
};
function Gr() {
  const { logWarning: e } = T();
  function r(a, o, i) {
    let l = null;
    return a.traverse((c) => {
      c[o] === i && (l = c);
    }), l || e(`Child with ${o} '${i}' not found.`), l;
  }
  function t(a, o, i) {
    const l = [];
    return a.traverse((c) => {
      c[o].includes(i) && l.push(c);
    }), l.length || e(`Children with ${o} '${i}' not found.`), l;
  }
  function n(a, o) {
    return r(a, "name", o);
  }
  function s(a, o) {
    return t(a, "name", o);
  }
  return {
    seek: r,
    seekByName: n,
    seekAll: t,
    seekAllByName: s
  };
}
const fr = ({ scene: e, contextParts: r }) => {
  const t = ge({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), n = R(/* @__PURE__ */ new Set()), s = (u) => {
    n.value.add(u);
  }, a = (u) => {
    n.value.delete(u);
  }, o = (u) => {
    Object.values(t).forEach((m) => m.delete(u)), a(u);
  }, i = (u) => {
    const { onClick: m, onPointerMove: y, onPointerEnter: f, onPointerLeave: h } = u;
    m && t.click.set(u, m), y && t.pointerMove.set(u, y), f && t.pointerEnter.set(u, f), h && t.pointerLeave.set(u, h);
  };
  e.userData.tres__registerAtPointerEventHandler = i, e.userData.tres__deregisterAtPointerEventHandler = o, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = a;
  const l = P(
    () => tr(
      [
        ...Array.from(n.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: c, onPointerMove: p } = dr(l, r);
  c(({ intersects: u, event: m }) => {
    var y;
    u.length && ((y = t.click.get(u[0].object)) == null || y(u[0], m));
  });
  let d;
  return p(({ intersects: u, event: m }) => {
    var w, C, S, b;
    const y = (w = u == null ? void 0 : u[0]) == null ? void 0 : w.object, { pointerLeave: f, pointerEnter: h, pointerMove: _ } = t;
    d && d !== y && ((C = f.get(d)) == null || C(d, m)), y && (d !== y && ((S = h.get(y)) == null || S(u[0], m)), (b = _.get(y)) == null || b(u[0], m)), d = y || null;
  }), {
    registerObject: i,
    deregisterObject: o
  };
};
function Se(e) {
  let r = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const n = t.geometry, s = n.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, a = n.index ? n.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, o = n.attributes.normal ? n.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, i = n.attributes.uv ? n.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + a + o + i;
      r += l;
    }
  }), r;
}
function pr(e) {
  return (e / 1024).toFixed(2);
}
const X = R({}), re = (e) => Object.assign(X.value, e);
function mr({
  scene: e,
  canvas: r,
  windowSize: t,
  disableRender: n,
  rendererOptions: s
}) {
  const a = P(
    () => M(t) ? _t() : Et(M(r).parentElement)
  ), o = D({
    width: 0,
    height: 0
  }), i = Mt(o, 10), l = O(() => {
    o.value = {
      width: a.value.width.value,
      height: a.value.height.value
    };
  }), c = P(() => i.value.width / i.value.height), p = {
    height: P(() => i.value.height),
    width: P(() => i.value.width),
    aspectRatio: c
  }, d = D(e), {
    camera: u,
    cameras: m,
    registerCamera: y,
    deregisterCamera: f,
    setCameraActive: h
  } = Gt({ sizes: p, scene: e }), { renderer: _ } = lr(
    {
      scene: e,
      canvas: r,
      options: s,
      contextParts: { sizes: p, camera: u },
      disableRender: n
    }
  ), w = {
    sizes: p,
    scene: d,
    camera: u,
    cameras: Re(m),
    renderer: _,
    raycaster: D(new st()),
    controls: R(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: re,
    registerCamera: y,
    setCameraActive: h,
    deregisterCamera: f
  };
  q("useTres", w);
  const C = 100, S = Ct({ every: C }), { isSupported: b, memory: x } = St({ interval: C }), g = 160;
  let E = performance.now();
  const Te = ({ timestamp: $ }) => {
    w.scene.value && (w.perf.memory.allocatedMem = Se(w.scene.value)), $ - E >= C && (E = $, w.perf.fps.accumulator.push(S.value), w.perf.fps.accumulator.length > g && w.perf.fps.accumulator.shift(), w.perf.fps.value = S.value, b.value && x.value && (w.perf.memory.accumulator.push(x.value.usedJSHeapSize / 1024 / 1024), w.perf.memory.accumulator.length > g && w.perf.memory.accumulator.shift(), w.perf.memory.currentMem = w.perf.memory.accumulator.reduce((De, Be) => De + Be, 0) / w.perf.memory.accumulator.length));
  };
  let G = 0;
  const Le = 1, { pause: Oe, resume: Rr } = we(({ delta: $ }) => {
    window.__TRES__DEVTOOLS__ && (Te({ timestamp: performance.now() }), G += $, G >= Le && (window.__TRES__DEVTOOLS__.cb(w), G = 0));
  }, { immediate: !0 });
  return F(() => {
    l(), Oe();
  }), w;
}
function gr() {
  const e = $e("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const Jr = gr;
let v = null;
const { logError: fe } = T(), Y = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
], vr = {
  createElement(e, r, t, n) {
    var o, i;
    if (n || (n = {}), n.args || (n.args = []), e === "template" || Zt(e))
      return null;
    let s = e.replace("Tres", ""), a;
    if (e === "primitive") {
      (n == null ? void 0 : n.object) === void 0 && fe("Tres primitives need a prop 'object'");
      const l = n.object;
      s = l.type, a = Object.assign(l, { type: s, attach: n.attach, primitive: !0 });
    } else {
      const l = X.value[s];
      l || fe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), a = new l(...n.args);
    }
    return a.isCamera && (n != null && n.position || a.position.set(3, 3, 3), n != null && n.lookAt || a.lookAt(0, 0, 0)), (n == null ? void 0 : n.attach) === void 0 && (a.isMaterial ? a.attach = "material" : a.isBufferGeometry && (a.attach = "geometry")), a.isObject3D && ((o = n == null ? void 0 : n.material) != null && o.isMaterial && (a.userData.tres__materialViaProp = !0), (i = n == null ? void 0 : n.geometry) != null && i.isBufferGeometry && (a.userData.tres__geometryViaProp = !0)), a.userData = {
      ...a.userData,
      tres__name: s
    }, a;
  },
  insert(e, r) {
    var n, s, a, o;
    r && r.isScene && (v = r);
    const t = r || v;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(v != null && v.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (s = v == null ? void 0 : (n = v.userData).tres__registerCamera) == null || s.call(n, e);
      }
      if (e && Y.some((i) => e[i])) {
        if (!(v != null && v.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (o = v == null ? void 0 : (a = v.userData).tres__registerAtPointerEventHandler) == null || o.call(a, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var r, t;
    if (e) {
      if (e.isObject3D) {
        const n = e, s = (c) => {
          var d, u;
          const p = c;
          c.userData.tres__materialViaProp || ((d = p.material) == null || d.dispose(), p.material = void 0), c.userData.tres__geometryViaProp || ((u = p.geometry) == null || u.dispose(), p.geometry = void 0);
        }, a = v == null ? void 0 : v.userData.tres__deregisterAtPointerEventHandler, o = v == null ? void 0 : v.userData.tres__deregisterBlockingObjectAtPointerEventHandler, i = (c) => {
          var p, d;
          if (!o)
            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
          if ((d = v == null ? void 0 : (p = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(p, c), !a)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          c && Y.some((u) => c[u]) && (a == null || a(c));
        }, l = (c) => {
          const p = v == null ? void 0 : v.userData.tres__deregisterCamera;
          if (!p)
            throw "could not find tres__deregisterCamera on scene's userData";
          c.isCamera && (p == null || p(c));
        };
        (r = e.removeFromParent) == null || r.call(e), n.traverse((c) => {
          s(c), l(c), i == null || i(c);
        }), s(n), l(n), i == null || i(n);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, r, t, n) {
    var s, a, o, i;
    if (e) {
      let l = e, c = r;
      if (e.isObject3D && c === "blocks-pointer-events") {
        n || n === "" ? (a = v == null ? void 0 : (s = v.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || a.call(s, e) : (i = v == null ? void 0 : (o = v.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || i.call(o, e);
        return;
      }
      let p = I(c), d = l == null ? void 0 : l[p];
      if (c === "args") {
        const m = e, y = t ?? [], f = n ?? [], h = e.userData.tres__name || e.type;
        h && y.length && !nr(y, f) && (l = Object.assign(m, new X.value[h](...n)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          I(c),
          new it(...n)
        );
        return;
      }
      if (c.includes("-") && d === void 0) {
        const m = c.split("-");
        d = m.reduce((y, f) => y[I(f)], l), c = m.pop(), p = c.toLowerCase(), d != null && d.set || (l = m.reduce((y, f) => y[I(f)], l));
      }
      let u = n;
      if (u === "" && (u = !0), de(d)) {
        Y.includes(r) || (Array.isArray(u) ? e[p](...u) : e[p](u));
        return;
      }
      !(d != null && d.set) && !de(d) ? l[p] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
}, { render: hr } = Ie(vr);
re(ve);
function yr() {
  return xe().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function xe() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof global < "u" ? global : {};
}
const wr = typeof Proxy == "function", br = "devtools-plugin:setup", _r = "plugin:settings:set";
let L, Z;
function Er() {
  var e;
  return L !== void 0 || (typeof window < "u" && window.performance ? (L = !0, Z = window.performance) : typeof global < "u" && (!((e = global.perf_hooks) === null || e === void 0) && e.performance) ? (L = !0, Z = global.perf_hooks.performance) : L = !1), L;
}
function Mr() {
  return Er() ? Z.now() : Date.now();
}
class Cr {
  constructor(r, t) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
    const n = {};
    if (r.settings)
      for (const o in r.settings) {
        const i = r.settings[o];
        n[o] = i.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${r.id}`;
    let a = Object.assign({}, n);
    try {
      const o = localStorage.getItem(s), i = JSON.parse(o);
      Object.assign(a, i);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return a;
      },
      setSettings(o) {
        try {
          localStorage.setItem(s, JSON.stringify(o));
        } catch {
        }
        a = o;
      },
      now() {
        return Mr();
      }
    }, t && t.on(_r, (o, i) => {
      o === this.plugin.id && this.fallbacks.setSettings(i);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, i) => this.target ? this.target.on[i] : (...l) => {
        this.onQueue.push({
          method: i,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, i) => this.target ? this.target[i] : i === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(i) ? (...l) => (this.targetQueue.push({
        method: i,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[i](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: i,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(r) {
    this.target = r;
    for (const t of this.onQueue)
      this.target.on[t.method](...t.args);
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args));
  }
}
function Sr(e, r) {
  const t = e, n = xe(), s = yr(), a = wr && t.enableEarlyProxy;
  if (s && (n.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !a))
    s.emit(br, e, r);
  else {
    const o = a ? new Cr(t, s) : null;
    (n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: t,
      setupFn: r,
      proxy: o
    }), o && r(o.proxiedTarget);
  }
}
function xr(e, r) {
  const t = `▲ ■ ●${e}`;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
}
const Pe = (e) => {
  const r = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && r.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const t = Se(e);
  return t > 0 && r.tags.push({
    label: `${pr(t)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (r.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), r.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (r.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), r.tags.push({
    // eslint-disable-next-line max-len
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), r;
};
function ke(e, r) {
  e.children.forEach((t) => {
    if (t.type === "HightlightMesh")
      return;
    const n = Pe(t);
    r.children.push(n), ke(t, n);
  });
}
const Pr = [], B = "tres:inspector", kr = ge({
  sceneGraph: null
});
function Ar(e, r) {
  Sr(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Pr,
      app: e
    },
    (t) => {
      typeof t.now != "function" && xr(
        // eslint-disable-next-line max-len
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), t.addInspector({
        id: B,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        t.sendInspectorTree(B);
      }, 1e3), setInterval(() => {
        t.notifyComponentUpdate();
      }, 5e3), t.on.getInspectorTree((a) => {
        if (a.inspectorId === B) {
          const o = Pe(r.scene.value);
          ke(r.scene.value, o), kr.sceneGraph = o, a.rootNodes = [o];
        }
      });
      let n = null, s = null;
      t.on.getInspectorState((a) => {
        if (a.inspectorId === B) {
          const [o] = r.scene.value.getObjectsByProperty("uuid", a.nodeId);
          if (!o)
            return;
          if (s && n && n.parent && s.remove(n), o.isMesh) {
            const i = ir(o);
            o.add(i), n = i, s = o;
          }
          a.state = {
            object: [
              {
                key: "uuid",
                editable: !0,
                value: o.uuid
              },
              {
                key: "name",
                editable: !0,
                value: o.name
              },
              {
                key: "type",
                editable: !0,
                value: o.type
              },
              {
                key: "position",
                editable: !0,
                value: o.position
              },
              {
                key: "rotation",
                editable: !0,
                value: o.rotation
              },
              {
                key: "scale",
                editable: !0,
                value: o.scale
              },
              {
                key: "geometry",
                value: o.geometry
              },
              {
                key: "material",
                value: o.material
              },
              {
                key: "color",
                editable: !0,
                value: o.color
              },
              {
                key: "intensity",
                editable: !0,
                value: o.intensity
              },
              {
                key: "castShadow",
                editable: !0,
                value: o.castShadow
              },
              {
                key: "receiveShadow",
                editable: !0,
                value: o.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: !0,
                value: o.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: !0,
                value: o.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: !0,
                value: o.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: o.matrixWorld
              },
              {
                key: "visible",
                editable: !0,
                value: o.visible
              }
            ]
          };
        }
      }), t.on.editInspectorState((a) => {
        a.inspectorId === B && sr(r.scene.value, a.nodeId, a.path, a.state.value);
      });
    }
  );
}
const Tr = ["data-scene", "data-tres"], Lr = /* @__PURE__ */ ne({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: r }) {
    var y;
    const t = e, { logWarning: n } = T(), s = R(), a = D(new at()), { resume: o } = te(), i = ze(), l = (y = oe()) == null ? void 0 : y.appContext.app, c = (f) => ne({
      setup() {
        var _;
        const h = (_ = oe()) == null ? void 0 : _.appContext;
        return h && (h.app = l), q("useTres", f), q("extend", re), typeof window < "u" && Ar(h.app, f), () => se(Je, null, i != null && i.default ? i.default() : []);
      }
    }), p = (f) => {
      const h = c(f);
      hr(se(h), a.value);
    }, d = (f, h = !1) => {
      a.value.children = [], h && (f.renderer.value.dispose(), f.renderer.value.renderLists.dispose(), f.renderer.value.forceContextLoss()), p(f), o();
    }, u = P(() => t.disableRender), m = D(null);
    return r({ context: m, dispose: () => d(m.value, !0) }), Ne(() => {
      const f = s;
      m.value = mr({
        scene: a.value,
        canvas: f,
        windowSize: t.windowSize,
        disableRender: u,
        rendererOptions: t
      }), fr({ scene: a.value, contextParts: m.value });
      const { registerCamera: h, camera: _, cameras: w, deregisterCamera: C } = m.value;
      p(m.value);
      const S = () => {
        const b = new K(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        b.position.set(3, 3, 3), b.lookAt(0, 0, 0), h(b);
        const x = O(() => {
          w.value.length >= 2 && (b.removeFromParent(), C(b), x == null || x());
        });
      };
      me(
        () => t.camera,
        (b, x) => {
          b && h(b), x && (x.removeFromParent(), C(x));
        },
        {
          immediate: !0
        }
      ), _.value || (n(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), S());
    }), (f, h) => (Ve(), We("canvas", {
      ref_key: "canvas",
      ref: s,
      "data-scene": a.value.uuid,
      class: Ue(f.$attrs.class),
      "data-tres": `tresjs ${Fe(Ft).version}`,
      style: Ge({
        display: "block",
        width: "100%",
        height: "100%",
        position: f.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...f.$attrs.style
      })
    }, null, 14, Tr));
  }
}), Or = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], Dr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Or.includes(e) || e === "primitive"
    }
  }
}, Qr = Dr, Yr = {
  mounted: (e, r) => {
    if (r.arg) {
      console.log(`v-log:${r.arg}`, e[r.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
class Ae extends lt {
  constructor(r, t) {
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new ie();
    s.setAttribute("position", new ae(n, 3)), s.computeBoundingSphere();
    const a = new ut({ fog: !1 });
    super(s, a), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], i = new ie();
    i.setAttribute("position", new ae(o, 3)), i.computeBoundingSphere(), this.add(new ct(i, new ye({ side: dt, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const { logWarning: pe } = T();
let N, A;
const Br = {
  DirectionalLight: ft,
  PointLight: pt,
  SpotLight: mt,
  HemisphereLight: gt,
  RectAreaLight: Ae
}, qr = {
  mounted: (e) => {
    if (!e.isLight) {
      pe(`${e.type} is not a light`);
      return;
    }
    N = Br[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    A = e.parent.children.find((r) => r instanceof N), !(A instanceof Ae) && A.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      pe(`${e.type} is not a light`);
      return;
    }
    A = e.parent.children.find((r) => r instanceof N), A && A.dispose && A.dispose(), e.parent.remove(A);
  }
}, { logWarning: jr } = T(), Kr = {
  updated: (e, r) => {
    const t = Ce(r);
    if (!t) {
      jr(`v-always-look-at: problem with binding value: ${r.value}`);
      return;
    }
    const { onLoop: n } = te();
    n(() => {
      e.lookAt(t);
    });
  }
}, { logWarning: Hr } = T(), Xr = {
  updated: (e, r) => {
    var s;
    const t = Ce(r);
    if (!t) {
      Hr(`v-distance-to: problem with binding value: ${r.value}`);
      return;
    }
    k && (k.dispose(), e.parent.remove(k));
    const n = t.clone().sub(e.position);
    n.normalize(), k = new vt(n, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
      [
        ["Distance:", e.position.distanceTo(t)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (e) => {
    k == null || k.dispose(), e.parent.remove(k);
  }
};
let k = null;
const Zr = {
  install(e) {
    e.component("TresCanvas", Lr);
  }
};
export {
  Lr as TresCanvas,
  X as catalogue,
  Zr as default,
  re as extend,
  Vr as isProd,
  qt as normalizeColor,
  Wr as normalizeVectorFlexibleParam,
  Qr as templateCompilerOptions,
  cr as trasverseObjects,
  Gt as useCamera,
  Ur as useLoader,
  T as useLogger,
  fr as usePointerEventHandler,
  dr as useRaycaster,
  te as useRenderLoop,
  lr as useRenderer,
  Gr as useSeek,
  Fr as useTexture,
  Jr as useTres,
  gr as useTresContext,
  mr as useTresContextProvider,
  Kr as vAlwaysLookAt,
  Xr as vDistanceTo,
  qr as vLightHelper,
  Yr as vLog
};
